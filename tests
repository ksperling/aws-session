#!/bin/bash
TEST_ROOT="$(dirname "$0")"
TEST_FIXTURES="$TEST_ROOT/fixtures"

TEST_TOTAL=0 TEST_FAIL=0 TEST_SKIP=0

function test_record() { # message
  if [[ $? = 0 ]]; then
    (( TEST_TOTAL++ ))
    echo -n .
  else
    (( TEST_TOTAL++, TEST_FAIL++ ))
    echo $'x\n'"$1"
  fi
}

function test_skip() { # count message
  (( TEST_TOTAL += "$1", TEST_SKIP += "$1" ))
  echo $'\n'"skipping $1 tests: $2"
  return 1
}

function expect_equal() { # message expected actual
  [[ "$2" = "$3" ]]; test_record "$1: expected '$2' but got '$3'"
}

###################################################################################################

source "$TEST_ROOT/aws-session"

### call

function _reply_return() { REPLY="$1"; return $2; }
function _reply_return_indirect { call REPLY=_reply_return "($1)" "$(( $2 + 1))"; }
function test_call() {
  local foo=prev value=' " result * `date`'
  call foo=_reply_return "$value" 23
  expect_equal "return code" 23 $?
  expect_equal "return value" "$value" "$foo"

  call foo=_reply_return_indirect "text" 42
  expect_equal "return code" 43 $?
  expect_equal "return value" "(text)" "$foo"
}
test_call

### basenm / dirnm

function test_basename_dirname() {
  local actual expected actual_rc expected_rc
  expected="$(command basename "$1")"; expected_rc=$?
  call actual=basenm "$1"; actual_rc=$?
  expect_equal "basename '$1' output" "$expected" "$actual"
  expect_equal "basename '$1' rc" "$expected_rc" "$actual_rc"

  expected="$(command dirname "$1")"; expected_rc=$?
  call actual=dirnm "$1"; actual_rc=$?
  expect_equal "dirname '$1' output" "$expected" "$actual"
  expect_equal "dirname '$1' rc" "$expected_rc" "$actual_rc"
}

for t in /aaa/bbb/  /  //  /aaa  aaa  aaa/  aaa/xxx  aaa//  a//b//c//  ''; do
  test_basename_dirname "$t"
done

### parse_utciso

function test_parse_utciso() {
  parse_utciso "$1"
  expect_equal "parse_utciso($1) return code" "$2" $?
  expect_equal "parse_utciso($1) result" "$3" "$REPLY"
}
test_parse_utciso "1970-01-01T00:00:00Z" 0 0
test_parse_utciso "2005-03-18T01:58:31Z" 0 1111111111
test_parse_utciso "" 1
test_parse_utciso "yesterday" 1

### read_binary

expect_equal "read_binary ..." "BC-F" "$(echo ABCDEFG | { read_binary 1 2 '1/1 "%c"'; echo -n "-"; read_binary 2 1 '1/1 "%c"'; })"

### img_reorder_topdown

expect_equal "img_reorder_topdown(0)" $'c\nb\na' "$(echo $'a\nb\nc' | img_reorder_topdown 0)"
expect_equal "img_reorder_topdown(1)" $'a\nb\nc' "$(echo $'a\nb\nc' | img_reorder_topdown 1)"

### img_scale_x

expect_equal "img_scale_x(2)" 'abc' "$(echo 'aabbcc' | img_scale_x 2)"
expect_equal "img_scale_x(3)" '# #' "$(echo '###   ###' | img_scale_x 3)"
expect_equal "img_scale_x(3, 2)" '##  ##' "$(echo '###   ###' | img_scale_x 3 2)"

### img_parse_png

if have_cmd convert || test_skip 1 "convert (ImageMagic) unavailable"; then
  expect_equal "img_parse_png_convert(3x3.png)" $'#  \n # \n## ' "$(img_parse_png <"$TEST_FIXTURES/3x3.png")"
fi

if have_cmd sips && [[ "$(uname -s)" = Darwin ]] || test_skip 1 "sips unavailable"; then
  expect_equal "img_parse_png_sips(3x3.png)" $'#  \n # \n## ' "$(img_parse_png <"$TEST_FIXTURES/3x3.png")"
fi

### img_trim_qr

expect_equal "img_trim_qr(qr.txt)" "$(cat "$TEST_FIXTURES/qr-trimmed.txt")" "$(img_trim_qr <"$TEST_FIXTURES/qr.txt")"


###################################################################################################

echo $'\n'"Total tests: ${TEST_TOTAL} skipped: ${TEST_SKIP} failed: ${TEST_FAIL}"
[[ "$TEST_FAIL" -eq 0 ]]
